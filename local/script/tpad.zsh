#!/usr/bin/env zsh
[ "${ZSH_VERSION:-}" = "" ] && echo >&2 "Only works with zsh" && exit 1
setopt err_exit no_unset pipefail

# Copyright © Martin Tournoij
# See the bottom of this file for the full copyright.

progname=${0:t}

# status
########
help-status() {
	<<-EOF
	Show the current system status.

	Units are omitted for brevity; battery values are in percentage, CPU in MHz,
	and temperature in °C.
EOF
}
get-thermal() {
	# Sort by temperature.
	typeset -A temps
	local width=0
	for t in /sys/class/hwmon/*/temp*_input; do
		local temp=$(< $t 2>/dev/null)
		[[ -z $temp || $temp = 0 ]] && continue
		temp=$(( temp / 1000 ))

		local name=$(< ${t:h}/name)
		local labelfile=${t//_input/_label}
		local label=
		[[ -r $labelfile ]] && label=${$(< $labelfile):l}
		label=${label//sensor /}
		label=${label// /-}

		case $label in
			(edge|tctl|composite|)  label="" ;;
			(*) label=.$label
		esac
		name=$name$label
		temps+=("$temp $name" "$name")
		(( $#name > $width )) && width=$#name
	done

	first=1
	for k in ${(knO)temps}; do
		(( ! $first )) && print -n '\n          '
		first=0
		print -nf "%-${width}s = %s" ${temps[$k]} ${k% *}
	done
}
get-fan() {
	awk -F: '/^(speed|level):/ { gsub(/[ \t]/, "", $2); printf "%s=%s ", $1, $2 }' /proc/acpi/ibm/fan
}
status() {
	print -f '\x1b[1mCharge:\x1b[0m   %s\n' "$(get-charge-limit)"
	print -f '\x1b[1mCPU:\x1b[0m      %s\n' "$(get-cpu)"
	print -f '\x1b[1mFan:\x1b[0m      %s\n' "$(get-fan)"
	print -f '\x1b[1mThermal:\x1b[0m  %s\n' "$(get-thermal)"
	print -f '\x1b[1mKnobs:\x1b[0m    %s\n' "$(get-knob)"
}

# save
######
help-save() {
	<<-EOF
	Save the current settings to a POSIX-compatible shell script. Running it
	doesn't require access to tpad.zsh.

	This is useful to apply the settings on startup, as most aren't persisted
	between boots.
EOF
}
save() {
	print '#!/bin/sh'
	print '#'
	print '# Script generated by "tpad.zsh save"'.
	print
	save-charge-limit
	save-cpu
	save-knob
}

# charge-limit
##############
help-charge-limit() {
	<<-EOF
	Set battery charge limits.

	This requires two arguments: start percentage and stop percentage. The
	battery won't charge if the level is above the start, and will stop charging
	if it's at stop.

	If more than one battery is present you can use the third argument to set
	the battery.
EOF
}
get-charge-limit() {
	local bats=(/sys/class/power_supply/BAT*)
	local first=1
	for b in $bats; do
		if (( $#bats > 1 )); then
			(( ! $first )) && print -n '\n          '
			first=0
			print -n "${b:t}: "
		fi

		print -nf 'start=%d stop=%d current=%d capacity=%d status=%s' \
			$(< $b/charge_start_threshold) $(< $b/charge_stop_threshold) $(< $b/capacity) \
			$(( $(< $b/energy_full).0 / $(< $b/energy_full_design).0 * 100 )) \
			"$(< $b/status)"

		if [[ $(< $b/status) = Discharging ]]; then
			local seconds=$(( 3600 *
				( $(< $b/energy_now).0 / $(< $b/voltage_now).0 ) /
				( $(< $b/power_now).0  / $(< $b/voltage_now).0 ) ))
			print -nf ' remaining=%02d:%02d' $(( $seconds / 3600 )) $(( $seconds / 60 % 60 ))
		fi
	done
}
set-charge-limit() {
	(( $#argv < 2 )) && help "need start and stop values" charge-limit
	local start=$argv[1]
	local stop=$argv[2]
	local bat=${argv[3]:-BAT0}

	print $start >/sys/class/power_supply/$bat/charge_start_threshold
	print $stop  >/sys/class/power_supply/$bat/charge_stop_threshold
}
save-charge-limit() {
	for b in /sys/class/power_supply/BAT*; do
		print "# Charge limits for $b:t"
		print "echo $(< $b/charge_start_threshold) >| $b/charge_start_threshold"
		print "echo $(< $b/charge_stop_threshold) >| $b/charge_stop_threshold"
		print
	done
}

# cpu
#####
help-cpu() {
    typeset -A can
    for s in $(< /sys/devices/system/cpu/cpu0/cpufreq/scaling_available_governors); \
        can[$s]=1

    print 'Set CPU governor and frequency.\n'
	print 'The first argument is the governor; supported on this system:\n'
    (( ${can[performance]:-0}  > 0 )) && print '   performance    Run at max frequency.'
	(( ${can[powersave]:-0}    > 0 )) && print '   powersave      Run at the minimum frequency.'
	(( ${can[ondemand]:-0}     > 0 )) && print '   ondemand       Dynamically switch if at 95% load.'
	(( ${can[conservative]:-0} > 0 )) && print '   conservative   Dynamically switch if at 75% load.'
	(( ${can[userspace]:-0}    > 0 )) && print '   userspace      Set fixed frequency.'
   <<-EOF

	For "userspace" it accepts a second argument to set the frequency, for
	everything else it accepts two arguments to set the min and max
	frequency. These arguments are optional.

	Set values for one CPU only by prefixing a value with the CPU number
	followed by a colon (:). For example:

	   % tpad.zsh cpu 0:powersave
	   % tpad.zsh cpu 0:powersave 0:1000 0:2000
	   % tpad.zsh cpu 0:powersave 0:1000 0:2000 1:performance
	   % tpad.zsh cpu powersave 0:performance
EOF
}
get-cpu() {
	local all=()
	for c in /sys/devices/system/cpu/cpu*/cpufreq; do
        local x="governor=$(< "$c/scaling_governor")"
        x+=" min_freq=$(( $(< $c/scaling_min_freq) / 1000 ))"
        x+=" max_freq=$(( $(< $c/scaling_max_freq) / 1000 ))"
		all+=($x)
    done

	if [[ ${#${(u)all}} -eq 1 ]]; then
		print ${(u)all}
	else
		# TODO: group CPUs with the same setting as "1-7: .."
		# TODO: align better
		local first=1
		for (( i=1; i <= $#all; i++ )); do
			(( ! $first )) && print -n '\n          '
			first=0
			print -n "$(( $i - 1 )): $all[$i]"
		done
	fi
}
set-cpu() {
	(( $#argv < 1 )) && help 'need at least one value to set' cpu

	local userspace=0
	local i=0
	for arg in $argv; do
		local cpu='*'
		if [[ $arg =~ '^[0-9]+:' ]]; then
			cpu=${arg%:*}
			arg=${arg#*:}
		fi

		i=$(( $i + 1 ))
		[[ $arg =~ '^[0-9]+$' ]] || i=0

		local knob=scaling_governor
		if (( $i == 0 )); then
			userspace=0
			[[ $arg = userspace ]] && userspace=1
		elif (( $i == 1 )); then
			arg=$(( $arg * 1000 ))
			knob=scaling_min_freq
			(( $userspace )) && knob=scaling_setspeed
		elif (( $i == 2 )); then
			arg=$(( $arg * 1000 ))
			knob=scaling_max_freq
		fi

		print $arg >/sys/devices/system/cpu/cpu${~cpu}/cpufreq/$knob
	done
}
save-cpu() {
	for c in /sys/devices/system/cpu/cpu*/cpufreq; do
		print "# cpufreq for $c:h:t"
		print "echo $(< $c/scaling_governor) >| $c/scaling_governor"
		print "echo $(< $c/scaling_min_freq)    >| $c/scaling_min_freq"
		print "echo $(< $c/scaling_max_freq)   >| $c/scaling_max_freq"
		print
	done
}

# monitor-fan
#############
help-monitor-fan() {
	<<-EOF
	Control the fan speed.

	The fan speed can be set from level 0 (off) to 7 (max speed), or the special
	values "auto" and "full-speed"; This is mostly useful to not be so
	aggressive in spinning the fan up.

	You can add any number of arguments to control when to set which level in
	the following syntax:

	   [operator][temperature]:[level]

	The operator is anything supported by zsh's (( .. )), the temperature is the
	highest temperature measured on this system, and the level one of the levels
	described above.

	The first match in the argument list will win. On shutdown it will reset the
	speed to "auto".

	Example:

	   monitor-fan '<60:0' '<70:1' '>=80:7'

	This will set the speed to 0 (off) if below 60°C, sets it to 1 (low) if
	below 70°C, and to 7 if it's higher than 80°C.
EOF
}
monitor-fan() {
	(( $#argv < 1 )) && help 'need at least one rule' monitor-fan

	local last_level=$( awk '/^level:/ { print $2 }' /proc/acpi/ibm/fan)
	trap 'print level auto >/proc/acpi/ibm/fan' EXIT INT

	local set_level=('if false; then { : }')
	# TODO: validate the arguments; right now it will just run (although it does
	# print an error).
	for a in $argv; do
	 	local l=${a##*:}
	 	local c=${a%%:*}
		set_level+=("elif (( \$max_temp $c )); then { level=$l }")
	done
	set_level+=("fi")
	set_level=${(j:;:)set_level}

	local level=auto
	while :; do
		local max_temp=($(cat /sys/class/hwmon/*/temp*_input)) 2>/dev/null
		max_temp=${${(on)max_temp}[-1]}
		max_temp=$(( max_temp / 1000 ))

		eval "$set_level"
		if [[ $level != $last_level ]]; then
			print -f '%s  temp %-3d  %-5s → %s\n' $(date +%T) $max_temp $last_level $level
			print level $level >/proc/acpi/ibm/fan
			last_level=$level
		fi
		sleep 3
	done
}

# knob
typeset -A knob_list=(
	led-power     /sys/class/leds/tpacpi::power/brightness
	led-lid       /sys/class/leds/tpacpi::lid_logo_dot/brightness
	led-micmute   /sys/class/leds/platform::micmute/brightness
	led-mute      /sys/class/leds/platform::mute/brightness
	led-keyboard  /sys/class/leds/tpacpi::kbd_backlight/brightness
	nmi-watchdog  /proc/sys/kernel/nmi_watchdog
	vm-writeback  /proc/sys/vm/dirty_writeback_centisecs
)
help-knob() {
	<<-EOF
	Allow setting various system "knobs".

	on/off values can be given as "on", "true", "1", or "t" for on, or "off",
	"false", "0", or "f" for off.

	   led-power       The power LED (on/off).
	   led-lid         The red dot on the "i" on the lid (on/off).
	   led-mute        The speaker mute LED (on/off).
	   led-micmute     The microphone mute LED (on/off).
	   led-keyboard    Keyboard backlight; 0 for off, 1 for dim, 2 for bright.
	   nmi-watchdog    The NMI watchdog generates a kernel panic if the system
	                   doesn't respond to periodic interupts. Useful, but sends
	                   interupts causing additional battery drain (on/off).
	   vm-writeback    How long to wait to flush data to disk, number in
	                   centiseconds (0.01s). Default is usually 500, or 5
	                   seconds.
EOF
}
get-knob() {
	w=0
	for k in ${(k)knob_list}; do
		(( $#k > $w )) && w=$#k
	done

	i=0
	for k in ${(ko)knob_list}; do
		local f=$knob_list[$k]
		(( $i > 0 && $i % 2 == 0 )) && print -n '\n          '
		print -f "%-${w}s = %-5s " $k $(< $f)
		i=$(( $i + 1 ))
	done
}
set-knob() {
	(( $#argv < 2 )) && help 'need knob and value' knob
	local k=$argv[1]
	local v=$argv[2]

	bool() {
		case $argv[1] in
			([oO][nN]|[tT][rR][uU][eE]|1|t)     print 1 ;;
			([oO][fF][fF]|[fF][aA][lL][sS]|0|f) print 0 ;;
		esac
	}

	case $k in
		(led-power)    print $(bool $v) >/sys/class/leds/tpacpi::power/brightness         ;;
		(led-lid)      print $(bool $v) >/sys/class/leds/tpacpi::lid_logo_dot/brightness  ;;
		(led-micmute)  print $(bool $v) >/sys/class/leds/platform::micmute/brightness     ;;
		(led-mute)     print $(bool $v) >/sys/class/leds/platform::mute/brightness        ;;
		(led-keyboard) print $v         >/sys/class/leds/tpacpi::kbd_backlight/brightness ;;
		(nmi-watchdog) print $(bool $v) >/proc/sys/kernel/nmi_watchdog                    ;;
		(vm-writeback) print $v         >/proc/sys/vm/dirty_writeback_centisecs           ;;
		#(suspend-usb)
			# TODO
			# Autosuspend for USB device USB Receiver [Logitech]
			# print 'auto' > '/sys/bus/usb/devices/1-3/power/control';
			#;;
		#(runtime-pm)
			# TODO
			# echo 'auto' > '/sys/bus/i2c/devices/i2c-1/device/power/control';
			# Runtime PM for I2C Adapter i2c-1 (AMDGPU DM i2c hw bus 1)
			#;;
		(*)
			help "unknown knob '$k'" knob
	esac

	# TODO
	# https://linrunner.de/tlp/settings/index.html
	# /proc/sys/vm/laptop_mode?

	# Contains various BIOS settings, but can't really seem to change it(?)
	# /sys/class/firmware-attributes/thinklmi/attributes
	# https://github.com/lenovo/thinklmi/tree/master/thinklmi-kernel
}
save-knob() {
	print "# Knobs"
	for k in ${(ko)knob_list}; do
		local f=$knob_list[$k]
		print -f "%-4s >| %-50s # %s\n" $(< $f) $f $k
	done
}

# help
help-top() {
	<<-EOF
	$progname controls some ThinkPad attributes.

	Commands overview:
	    help          Show help.
	    status        Print status.
	    save          Save current settings as a shell script.
	    charge-limit  Set battery charge limits.
	    cpu           Set CPU governor and frequency.
	    monitor-fan   Dynamically adjust fan based on temperature.
	    knob          Control various "knobs".

	Use "help <cmd>" for more help for a command, or "help all" to list the
	full help for all commands.
EOF
}
help() {
	[[ -n "${argv[1]:-}" ]] && print >&2 "$progname: error: ${argv[1]}\n"
    cmd=${argv[2]:-}

	case $cmd in
		('')           help-top          ;;
		(status)       help-status       ;;
		(save)         help-save         ;;
		(charge-limit) help-charge-limit ;;
		(cpu)          help-cpu          ;;
		(monitor-fan)  help-monitor-fan  ;;
		(knob)         help-knob         ;;
		(all)
			help-top
			print
			for a in help-status help-save help-charge-limit help-cpu help-monitor-fan help-knob; do
				local h="Help for ${a#*-}"
				print "─── \x1b[1m ${(r:60::─::\x1b[0m :)h}"
				print
				eval $a
				print
			done
			;;
		(*) help "unknown help topic: $cmd"
	esac

	if [[ -n "${argv[1]:-}" ]] && exit 1 || exit 0
}

# main
main() {
	cmd="status"
	if (( $#argv > 0 )); then
		cmd=$argv[1]
		shift
	fi
	case "$cmd"; in
		(help|-h|-help|--help)  help '' ${argv[1]:-}   ;;
		(status)                status                 ;;
		(save)                  save                   ;;
		(cpu)                   set-cpu $argv          ;;
		(charge-limit)          set-charge-limit $argv ;;
		(knob)                  set-knob $argv         ;;
		(monitor-fan)           monitor-fan $argv      ;;
		(*)                     help "unknown command: $cmd"
	esac
}
main $argv[@]


# The MIT License (MIT)
# 
# Copyright © Martin Tournoij
# 
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to
# deal in the Software without restriction, including without limitation the
# rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
# sell copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
# 
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
# 
# The software is provided "as is", without warranty of any kind, express or
# implied, including but not limited to the warranties of merchantability,
# fitness for a particular purpose and noninfringement. In no event shall the
# authors or copyright holders be liable for any claim, damages or other
# liability, whether in an action of contract, tort or otherwise, arising
# from, out of or in connection with the software or the use or other dealings
# in the software.
