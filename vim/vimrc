vim9script
set encoding=utf-8                     # Make sure UTF-8 is used.
scriptencoding utf-8

set nocompatible                       # Ensure it works with 'vim -u'
syntax on                              # Switch syntax highlighting on.
filetype plugin indent on              # Enable filetype detection.

set termguicolors                      # Use true colors.
&t_8f = "\<Esc>[38;2;%lu;%lu;%lum"     # Set correct escape codes to make termguicolors work in st.
&t_8b = "\<Esc>[48;2;%lu;%lu;%lum"
silent! colorscheme default2           # Load my color scheme if it exists.
set backspace=indent,eol,start         # Allow backspacing over everything.
set history=500                        # Keep 500 lines of command line history.
set incsearch                          # Jump to match while typing the pattern in /.
set hlsearch                           # Highlight last used search pattern.
set ignorecase                         # Case-insensitive searching unless \C is in the pattern…
set smartcase                          # …or the pattern contains an upper-case letter.
set nowrapscan                         # Don't wrap search.
set gdefault                           # Always use the /g flag with :s; add /g to restore the default.
set textwidth=80                       # Wrap at at 80 characters.
set linebreak                          # Wrap at word.
set showbreak=↪                        # Display at the start of line for wrapped lines.
set breakindent                        # When wrapping show next line on the same indent level.
set breakindentopt=sbr,list:-1         # sbr  → Display showbreak before indent.
                                       # list → indent list if it matches formatlistpat
&formatlistpat = '\v^\s*%(\d+[:.\)\t ]|-)\s+'  # Recognize "- " lists.
set autoindent                         # Copy indent from current line when starting a new line.
set backup                             # Keep backup file when writing.
set backupext=.bak                     # Extension for backup files (modified in autocmd below).
set backupskip=/tmp/*                  # No backup for these files.
set listchars=tab:!·,trail:·           # String to use in 'list' mode.
set spelllang=en_gb                    # Default language for spell check.
set spelloptions=camel                 # Spellcheck CamelCase words separately.
set helplang=en langmenu=en            # Always use English in help and UI.
set scrolloff=3                        # Minimum number of lines to keep above/below cursor.
set wildmenu                           # Better tab completion at the command-line.
set wildmode=longest:full              # Complete longest match, list other matches in wildmenu.
set wildignorecase                     # Case is ignored when completing file names and directories.
set wildignore=*.o,*.png,*.jpg,*.jpeg,*.webp,*.gif  # Ignore these files in completion.
set wildoptions=pum                    # Show pop-up menu.
set wildcharm=<Tab>                    # Trigger wild mode from mappings/macros.
set completeopt=menuone,noselect       # Insert mode completion:
                                       # menuone   → always show menu, even when there is 1 match.
                                       # noselect  → don't select an option when starting.
set completepopup=highlight:Pmenu,border:off  # Options for preview popup in completion.
set pumheight=10                       # Don't make completion menu too high.
set previewheight=6                    # Height of preview window.
set infercase                          # Like smartcase for insert completion.
set tabpagemax=500                     # Max. number of tabs to be open with -p argument or :tab all.
set showcmd                            # Show partial command in the last line of the screen.
set formatoptions+=j                   # Remove comment character when joining lines with J.
set nojoinspaces                       # Don't add two spaces after interpunction when using J.
set shiftround                         # Round indent to multiple of shiftwidth when using < and >
set smarttab                           # Backspace at start of line remove shiftwidith worth of space.
set matchpairs+=<:>                    # Also match < & > with %.
set switchbuf=useopen,usetab,newtab    # Use open tab (if any) when trying to jump to a quickfix error.
set noexpandtab                        # Real men use real tabs…
set tabstop=4                          # …which are always 4 spaces wide.
set shiftwidth=0                       # Use tabstop value.
set softtabstop=-1                     # Use shiftwidth value.
set synmaxcol=500                      # Maximum column in which to search for syntax items.
set t_ti= t_te=                        # Prevent clearing the terminal on exit.
set mouse=                             # I don't want mouse support.
set nrformats=bin,hex,unsigned         # Don't increment octal numbers, and ignore '-' in front of nrs.
set paragraphs=                        # Don't include nroff stuff.
set tildeop                            # Use ~ as an operator to switch case.
set clipboard=                         # Never automatically interface with system clipboard.
set nofoldenable                       # Disable folds by default.
set laststatus=2                       # Always show statusline.
set undofile                           # Save undo to file.
set notitle                            # Don't update term title.
set shortmess-=S                       # Show match count on n.
set virtualedit=block                  # Allow virtual editing in visual block mode.
&ttyfast = $SSH_CLIENT == ''           # Assume the terminal is fast for smoother redrawing.
set display=lastline,uhex              # lastline → Show as much of the last line as possible instead of @.
                                       # uhex     → Always show unprintable chars as <xx> instead of ^C.
set updatecount=50                     # Write to swap every 50 characters; swap file is also written if
                                       # nothing happens for 4 seconds (as set by the 'updatetime' setting).
set diffopt=internal,filler,closeoff,indent-heuristic,algorithm:histogram
                                       # filler            Show filler lines.
                                       # internal          Use internal library.
                                       # closeoff          Run :diffoff when closing the other split.
                                       # indent-heuristic  Better detection of whitespace diffs.
                                       # algorithm         Better algorithm
set formatoptions+=ncroql              # n   Recognize numbered lists when formatting (see formatlistpat)
                                       # c   Wrap comments with textwidth
                                       # r   Insert comment char after enter
                                       # o   Insert comment char after o/O
                                       # q   Format comments with gq
                                       # l   Don't break lines when they were longer than textwidth to start with.
set foldcolumn=0                       # Don't show foldcolumn.
set diffopt+=foldcolumn:0              # Don't reset foldcolumn for diff files.
&fillchars = 'vert: ,diff: ,fold: ,foldsep:│,foldopen:┌' # Don't show any fill characters for vsplit
                                                         # or removed diff lines; colour is enough.
# set preserveindent
set statusline=
&statusline ..= '%<%f'                 # Filename, truncate right
&statusline ..= ' %h%m%r'              # [Help] [modified] [read-only]
&statusline ..= '%{len(getqflist()) > 0 ? "[QE]" : ""}'
&statusline ..= '%{len(getloclist(0)) > 0 ? "[LE]" : ""}'

&statusline ..= '%='                   # Right-align from here on.
&statusline ..= ' [line %l of %L]'     # current line, total lines.
&statusline ..= ' [col %v]'            # column.
&statusline ..= ' [0x%B]'              # Byte value under cursor.

# Set/create directory to keep backup, swap, undo files.
set backupdir=$HOME/.cache/vim/backup | call mkdir(&backupdir, 'p', 0700)
set directory=$HOME/.cache/vim/swap   | call mkdir(&directory, 'p', 0700)
set undodir=$HOME/.cache/vim/undo     | call mkdir(&undodir, 'p', 0700)

# Set viminfo file location unless explicitly turned off.
if &viminfofile != 'NONE' | set viminfofile=$HOME/.cache/vim/viminfo | endif

### Autocmds
############
augroup my-autocmds
    au!

    # Add full path as backup extension, so files with the same name don't
    # override unrelated files:
    #
    #   README.markdown-%home%martin%code%uni%README%markdown
    #   README.markdown-%home%martin%code%goatcounter%README%markdown
    au BufWritePre * &backupext = '-' .. substitute(expand('<afile>:p'), '[^a-zA-Z0-9_-]', '%', 'g')

    # Go to the last cursor location when a file is opened unless this is a git commit.
    au BufReadPost * {
        if line("'\"") > 1 && line("'\"") <= line("$") && &filetype != 'gitcommit'
            exe 'normal! g`"'
        endif
    }

    # Don't spellcheck urls.
    au BufReadPost * syn match UrlNoSpell '\w\+:\/\/[^[:space:]]\+' contains=@NoSpell

    # Filetype overrides.
    au Filetype awk  {
        setl et
        # Don't need to highlight so much.
        # TODO: this breaks if I put the "hi link" after "syn clear"
        # hi link awkFieldVars NONE
        # hi link awkVariables Function
        # syn clear awkComma awkSemicolon awkExpression awkOperator awkSpecialPrintf awkPatterns awkBoolLogic awkCharClass awkBrktRegExp awkBrackets awkRegExp awkSpecialCharacter awkArrayElement awkArray
    }
    au Filetype css         setl isk+=-
    au Filetype html {
                            setl textwidth=100 indentexpr=
                            if $TMUX != ""
                                hi htmlItalic cterm=underline
                            endif
    }
    au Filetype javascript  hi def link javaScriptValue Number
    au Filetype lua         hi link luaTable Normal
    au filetype make        setl ts=8
    au Filetype markdown {
                            setl expandtab noshiftround
                            hi markdownError ctermbg=NONE
    }
    au Filetype python {
                            setl ts=4
                            g:pyindent_open_paren = 'shiftwidth()'
                            g:pyindent_continue   = 'shiftwidth()'
    }
    # Don't spellcheck comments, but do spellcheck strings.
    au Filetype toml {
                            syn match tomlComment /#.*/ contains=tomlTodo
                            syn region tomlString oneline start=/"/ skip=/\\\\\|\\"/ end=/"/ contains=tomlEscape,@Spell
                            syn region tomlString oneline start=/'/ end=/'/                  contains=@Spell
                            syn region tomlString start=/"""/ end=/"""/ contains=tomlEscape,tomlLineEscape,@Spell
                            syn region tomlString start=/'''/ end=/'''/ contains=@Spell
    }
    au Filetype vim {
                            setl keywordprg=:tab\ help
                            silent! syn clear vimCommentString vimCommentTitle
                            silent! hi vimSep guifg=NONE
    }
    au Filetype yaml        setl expandtab ts=2
    au Filetype zsh         hi link zshTypes Statement
augroup end

### Commands
############

# Convert buffer to and from scratch.
command S {
    if &buftype == 'nofile'
        setl swapfile buftype= bufhidden=
    else
        setl noswapfile buftype=nofile bufhidden=hide
    endif
    echo printf('swapfile=%s buftype=%s bufhidden=%s', &swapfile, &buftype, &bufhidden)
}

# Clean trailing whitespace.
command TrimWhitespace {
    var save = winsaveview()
    keeppattern :%s/\s\+$//e
    winrestview(save)
}

# Sort whitespace separated words
command SortWords {
    getline('.')->trim()->split('')->sort()->join(' ')->setline('.')
}

# Call uni on current character or visual selection.
command -range UnicodeName {
    var save = @a
    if <count> == -1
        @a = strcharpart(strpart(getline('.'), col('.') - 1), 0, 1)
    else
        exe 'normal! gv"ay'
    endif
    echo system('uni -q i', @a)[: -2]
    @a = save
}

# Stay on top of things!
# TODO: maybe also hook in to cursormoved?
command KeepTop {
    if execute('nmap <buffer> j') =~# 'jzt$'
        &scrolloff = b:scrolloff
        unlet b:scrolloff
        nunmap <buffer> j
        nunmap <buffer> <Down>
        nunmap <buffer> n
        nunmap <buffer> N
        echo 'Unmapped'
    else
        b:scrolloff = &scrolloff
        set scrolloff=0
        nnoremap <buffer> j jzt
        nnoremap <buffer> n nzt
        nnoremap <buffer> N Nzt
        nnoremap <buffer> <Down> jzt
        exe 'normal! zt'
        echo 'Keeping on top of things!'
    endif
}

# Sum up all numbers in a selection.
#
# This removes all non-numbers, so that it works when summing:
#
#  Personal plans        € 44
#  Personal plus plans   € 20
#  Stripe costs         -€ 14
#
# It will just add 44, 20, and -14 (resulting in 50).
# TODO: :%Sum doesn't work quite right?
command -range Sum {
    if <count> == -1
        echohl ErrorMsg | echom 'Sum: need selection' | echohl None
    else
        var save = @a
        exe 'silent normal! gv"ay'
        var lines = @a
        @a = save

        var total = 0.0
        for line in substitute(lines, '[^0-9.\n-]', '', 'g')->split('\n')
            total += line->str2float()
        endfor
        echom printf('Total: %f', total)
    endif
}

# Load the output of a command in the current buffer.
command -complete=command -nargs=+ Load call(
    \ (getline(1, '$')->filter((_, v) => len(v) > 0)->len() == 0 ? 'setline' : 'append'),
    \ ['.', execute(<q-args>)->split('\n')])

### Mappings
############

# Reload config.
nnoremap <Leader>r :source $MYVIMRC<CR>

# Some useful-ish toggles.
nnoremap <F9>  :set shiftround!<CR>:set shiftround?<CR>
nnoremap <F10> :set list!<CR>:set list?<CR>
nnoremap <F11> :set cursorcolumn!<CR>:set cursorcolumn?<CR>
nnoremap <F12> :set cursorline!<CR>:set cursorline?<CR>
inoremap <F9>  <Cmd>:set shiftround!<CR>
inoremap <F10> <Cmd>:set list!<CR>
inoremap <F11> <Cmd>:set cursorcolumn!<CR>
inoremap <F12> <Cmd>:set cursorline!<CR>

# Switch spell check languages
nnoremap <Leader>ss :set spell!<CR>:set spell?<CR>
nnoremap <Leader>sn :set spelllang=nl<CR>
nnoremap <Leader>se :set spelllang=en_gb<CR>

# Use <C-l> to clear some highlighting, and make sure it works from insert mode.
nnoremap <silent> <C-l> :nohlsearch<CR>:setl nolist nospell<CR>:diffupdate<CR><C-l>
inoremap <C-l> <Cmd>:exe "normal \<C-l>"<CR>
nnoremap <silent> <Leader>l :syntax sync fromstart<CR><C-l>

# We don't need no stinkin' ex mode; use it for formatting.
noremap Q gq

# Bloody annoying.
nnoremap q: :q

# Interface with system clipboard.
noremap <Leader>y "*y
noremap <Leader>p "*p
noremap <Leader>Y "+y
noremap <Leader>P "+p

# Indent in visual and select mode automatically re-selects.
vnoremap > >gv
vnoremap < <gv

# Make n always search forward, even when started with ?
nnoremap <expr> n 'Nn'[v:searchforward]
nnoremap <expr> N 'nN'[v:searchforward]

# Don't move cursor on * and #
nnoremap <silent> * :let @/ = '\<' .. expand('<cword>') ..  '\>' \| :call histadd('/', @/) \| :set hlsearch<CR>
nmap # *

# Use visual movement rather than line movement.
nnoremap k gk
nnoremap j gj
nnoremap <Up>   gk
nnoremap <Down> gj
inoremap <expr> <Up>   pumvisible() ? "\<C-p>"  : "\<C-o>gk"
inoremap <expr> <Down> pumvisible() ? "\<C-n>"  : "\<C-o>gj"

# Suspend also works from insert.
#inoremap <C-z> <Cmd><C-z>

# Doc on <C-k> in insert.
inoremap <C-k> <Cmd>:silent! normal! K<CR>

# Use <C-o> for history, as I use <C-p> as the tmux prefix key.
cnoremap <C-o> <Up>

# Readline-y mappings
inoremap        <C-A> <C-O>^
cnoremap        <C-A> <Home>
inoremap <expr> <C-E> col('.') > strlen(getline('.')) \|\| pumvisible() ? "\<C-E>" : "\<End>"

# Numpad
nnoremap <Esc>Ox <Up>
nnoremap <Esc>Ov <Right>
nnoremap <Esc>Or <Down>
nnoremap <Esc>Ot <Left>

# Use a reasonable completion.
def <SID>guessType(): string
    # TODO: Show original word somewhere.
    # TODO: Make completion start even if word is after badly spelled word.
    if &spell && spellbadword()[1] != '' | return "\<C-x>s"
    elseif &completefunc != ''           | return "\<C-x>\<C-u>"
    elseif &omnifunc != ''               | return "\<C-x>\<C-o>"
    else                                 | return "\<C-x>\<C-n>"
    endif
enddef
inoremap <expr> <C-@> pumvisible() ? "\<C-n>"  : <SID>guessType()
nnoremap <expr> <C-@> pumvisible() ? "i\<C-n>" : 'i' . <SID>guessType()

# Always insert spaces after non-whitespace, unless colorcolumn is enabled, in
# which case cc_align to align with that.
inoremap <expr> <Tab> &cc == '' ? (getline('.')[: col('.') - 2] =~ '^\s*$' ? "\<Tab>" : repeat(' ', (virtcol('.') % shiftwidth()) + 1)) : cc_align#tab()
# https://vi.stackexchange.com/a/37138/51
#inoremap <expr> <Tab> getline('.')[: col('.') - 2] =~ '^\s*$' ? "\<Tab>" : repeat(' ', shiftwidth())
#inoremap <expr> <Tab> getline('.')[: col('.') - 2] =~ '^\s*$' ? "\<Tab>" : repeat(' ', (virtcol('.') % shiftwidth()) + 1)

# Make <Tab> go to the next entry when using the popupmenu from commandline
# completion.
cnoremap <expr> <Tab> pumvisible() ? '<Down>' : "\<Tab>"

# Yank without clobbering registers.
nnoremap dD "_dd

# Replace the current line with the unnamed register.
nnoremap RR "_ddP

# Write and run :make.
nnoremap <silent> MM :silent! :wa<CR>:echo &makeprg<CR>:silent make<CR>:redraw!<CR>

# Close all windows except the current one.
nnoremap <silent> OO :silent wincmd o<CR>

# Open tabs faster.
nnoremap TT :tabe<Space>
nnoremap HH :tab h<Space>

# Open directory in new tab.
nnoremap <Leader>d :tabe %:h<CR>

# Don't do anything on space in insert mode; it's almost always an accident.
nnoremap <Space> <Nop>

# gf and gF opens in a tab.
nnoremap gf <C-w>gf
vnoremap gf <C-w>gf
nnoremap gF <C-w>gF
vnoremap gF <C-w>gF

# Navigate tabs
nnoremap <F1>         gT
nnoremap <F2>         gt
inoremap <F1>         <Esc>gT
inoremap <F2>         <Esc>gt
# Control+F1 and F2
nnoremap <Esc>[25~ gT :tabfirst<CR>
nnoremap <Esc>[26~ gt :tablast<CR>
nnoremap <Esc>[1;2P   :tabfirst<CR>
nnoremap <Esc>[1;2Q   :tablast<CR>
inoremap <Esc>[25~ gT <Esc>:tabfirst<CR>
inoremap <Esc>[26~ gt <Esc>:tablast<CR>
inoremap <Esc>[1;2P   <Esc>:tabfirst<CR>
inoremap <Esc>[1;2Q   <Esc>:tablast<CR>

# I often mistype this :-/
cabbr Set set
cabbr Help help
cabbr tane tabe
cabbr ta tabe
iabbr teh the
iabbr hte the
iabbr Teh The
iabbr seperated separated
iabbr seperate separate
iabbr taht that

# Makes stuff a bit easier to type.
iabbr 1= !=
iabbr ;= :=
iabbr :+ :=
iabbr err1= err !=
iabbr err!= err !=

# Add/remove word delimiters in search pattern.
# word → \<word\> → word
def <SID>wrap(): string
    var l = getcmdline()
    var pos = getcmdpos()
    # Remove
    if l[: 1] == '\<' && l[-2 :] == '\>'
        setcmdpos(pos - 2)
        return l[2 : len(l) - 3]
    endif
    # Add
    if l[: 1] != '\<'
        l = '\<' .. l
        pos += 2
    endif
    if l[-2 :] != '\>'
        l ..= '\>'
    endif
    setcmdpos(pos)
    return l
enddef
cnoremap <expr> <C-s> index(['/', '?'], getcmdtype()) == -1 ? "\<C-s>" : "\<C-\>e<SID>wrap()\<CR>"

### Plugins
###########
g:loaded_netrwPlugin = 1

### switchy.vim
nnoremap <silent> <Leader>a :call switchy#switch('tabedit', 'sbuf')<CR>

### lazy.vim
def R(file: string): list<string>
    var f = $HOME .. '/.vim/snip/' .. file
    return filereadable(f) ? readfile(f) : ''
enddef
g:lazy_snippets = {
    go: {
        err:  "if err != nil {\n\treturn fmt.Errorf(\"\b: %w\", err)\n}",
        errt: "if err != nil {\n\tt.Fatal(err)\n}",
        tt:   R('/test.go'),
        dp:   "fmt.Println(zdb.ApplyPlaceholders(\bquery, args...))",
        dd:   "zdb.Dump(ctx, os.Stdout, \"\b\")",
        bb:   "func Benchmark\b(b *testing.B){\n\tb.ReportAllocs()\n\tfor n := 0; n < b.N; n++ {\n\t}\n}\n"
    },
    html: {
        doc: R('/base.html'),
    },
}

### vim-dirvish
###############
g:dirvish_relative_paths = 1       # Make paths in the Dirvish buffer relative to getcwd().
augroup my-dirvish
    au!
    au Filetype dirvish
        #\ Remap as I often use q to close the Vim pager.
        | silent! nunmap <buffer> q
        | nmap <buffer> Q <Plug>(dirvish_quit)
        #\ Add tab mappings
        | nnoremap <buffer> t :call dirvish#open('tabedit', 0)<CR>
        | xnoremap <buffer> t :call dirvish#open('tabedit', 0)<CR>
        #\ Launch shell in cwd
        | nnoremap <silent> <buffer> <C-t> :lcd %<CR>:silent exec '!' .. (has('gui_running') ? 'st -e ' : '') .. $SHELL<CR><C-l>
augroup end

### gopher.vim
g:gopher_debug         = ['commands', 'setup']
g:gopher_highlight     = ['string-spell', 'string-fmt']
#g:gopher_build_command = 'install -race'
augroup my-gopher
    au!
    au FileType go
                #\ Highlight comments starting with /// less.
                | syn region goCommentBg start="///" end="$" contains=@Spell
                | hi goCommentBg guifg=#aaaaaa ctermfg=grey
                #\ Make ! stand out a bit more in '!foo'.
                | syn match goBang /!\ze[^=]/
                | hi goBang gui=bold cterm=bold
                #\ Compile without cgo unless explicitly enabled.
                | if $CGO_ENABLED == '' | $CGO_ENABLED = 0 | endif

    au FileType c,cpp
                #\ Highlight comments starting with /// less.
                | syn region cCommentBg start="///" end="$" contains=@Spell
                | hi cCommentBg guifg=#aaaaaa ctermfg=grey

    # Quick replace for go.mod
    au FileType gomod comm! -nargs=1 Replace append(4, printf('replace zgo.at/%s => ../../Golib/%s', <f-args>, <f-args>))

    # Format buffer on write; https://vi.stackexchange.com/questions/7116
    au BufWritePre *.go {
        var save = winsaveview()
        silent! exe 'undojoin | keepjumps :%!goimports 2>/dev/null || cat /dev/stdin'
        winrestview(save)
    }
augroup end

### vim-qf
g:qf_auto_open_quickfix = 1        # Automatically open qfix and loclist.
g:qf_auto_open_loclist = 1
# let g:qf_auto_quit = 0  # Breaks with tabs.
augroup my-qf
    au!
    # Close list when entering tabs and they're empty.
    au TabEnter *
                \ if len(getqflist()) == 0
                |     cclose
                | else
                |     qf#OpenQuickfix()
                |     wincmd w
                | endif
augroup end

# Go to next/prev error; need to use escape codes as <C-Arrow> isn't reliable.
nmap <C-Left>    <Plug>(qf_qf_previous)
nmap <Esc>[D >   <Plug>(qf_qf_previous)
nmap <Esc>[1;5D  <Plug>(qf_qf_previous)
nmap <C-Right>   <Plug>(qf_qf_next)
nmap <Esc>[C     <Plug>(qf_qf_next)
nmap <Esc>[1;5C  <Plug>(qf_qf_next)

# Toggle quickfix list.
nmap <C-Up>      <Plug>(qf_qf_toggle_stay)
nmap <Esc>[A     <Plug>(qf_qf_toggle_stay)
nmap <Esc>[1;5A  <Plug>(qf_qf_toggle_stay)

### vim-lsc
g:lsc_server_commands = {
    #go:           {command: '/home/martin/gopls',   log_level: -1, suppress_stderr: v:true},
    go:           {command: 'gopls serve',   log_level: -1, suppress_stderr: v:true},
    c:            {command: 'clangd',        log_level: -1, suppress_stderr: v:true},
    cpp:          {command: 'clangd',        log_level: -1, suppress_stderr: v:true},
    sql:          {command: 'sqls',          log_level: -1, suppress_stderr: v:true},
    'sql.runbuf': {command: 'sqls',          log_level: -1, suppress_stderr: v:true},
    rust:         {command: 'rust-analyzer', log_level: -1, suppress_stderr: v:true},
    zig:          {command: 'zls',           log_level: -1, suppress_stderr: v:true},
}
# cmd = { "/path/to/omnisharp-roslyn/bin/omnisharp/run", "--languageserver" , "--hostPID", tostring(pid) },

g:lsc_enable_autocomplete = v:false      # Don't complete when typing.
g:lsc_enable_diagnostics = v:false       # Don't lint code.
g:lsc_reference_highlights = v:false     # Don't highlight references.
#g:lsc_enable_incremental_sync = v:false  # Don't constantly send diffs to server.
#g:lsc_preview_split_direction = 'below'  # Show preview at bottom, rather than top.

g:lsc_auto_map = {defaults: v:true, GoToDefinitionSplit: ''}
augroup my-lsc
    au!
    # Open in tab, rather than split.
    au BufNewFile,BufReadPost *
        \  if has_key(get(g:, 'lsc_servers_by_filetype', {}), &filetype) && lsc#server#filetypeActive(&filetype)
        \|   nnoremap <buffer> gd :tab LSClientGoToDefinitionSplit<CR>
        \| endif
augroup end

# One command rather than a bunch.
var commands = {
    enable:          'lsc#server#enable',
    disable:         'lsc#server#disable',
    restart:         'lsc#server#restart',
    docs:            'lsc#reference#documentSymbols',
    hover:           'lsc#reference#hover',
    rename:          'lsc#edit#rename',
    references:      'lsc#reference#findReferences',
    implementations: 'lsc#reference#findImplementations',
    actions:         'lsc#edit#findCodeActions',
    goto:            'lsc#reference#goToDefinition',
    grep:            'lsc#search#workspaceSymbol',
}
# Not implemented:
# LSClientNextReference      call lsc#reference#findNext(1)
# LSClientPreviousReference  call lsc#reference#findNext(-1)
# LSClientAllDiagnostics     call lsc#diagnostics#showInQuickFix()
# LSClientLineDiagnostics    call lsc#diagnostics#echoForLine()
# LSClientSignatureHelp      call lsc#signaturehelp#getSignatureHelp()
# LSClientWindowDiagnostics  call lsc#diagnostics#showLocationList()
command -nargs=* -complete=customlist,<SID>lsc_complete LSC :call <SID>lsc(<f-args>)
def <SID>lsc(...args: list<string>)
    if len(args) == 0
        return
    endif

    var run = commands->get(args[0], v:none)
    if run == v:none
        echohl ErrorMsg | echo 'Unknown command: ' .. args[0] | echohl None
        return
    endif
    if args[0] == 'goto'
        function(run)->call(['', 0])
        return
    endif
    function(run)->call(args[1 :])
enddef
def <SID>lsc_complete(lead: string, cmdline: string, pos: number): list<string>
    var word = gopher#compl#prev_word(cmdline, pos)
    if word == 'LSC'
        return commands->keys()->filter((_, v) => strpart(v, 0, len(lead)) == lead)
    endif
    return []
enddef

### runbuf.vim
g:runbuf_commands = {gc: 'psql goatcounter', gcp: 'psql goatcounter_part'}
g:runbuf_map      = '<C-q>'
augroup my-runbuf
    au!
    au Filetype *.runbuf
        \  nnoremap <buffer> <C-j> :echo win_execute(win_getid(bufnr(b:output)), "normal! 3\<lt>C-e>")<CR>
        \| nnoremap <buffer> <C-k> :echo win_execute(win_getid(bufnr(b:output)), "normal! 3\<lt>C-y>")<CR>
augroup end

### xdg_open.vim
g:xdg_open_no_map = 1
nnoremap <silent> gx :call xdg_open#open(0)<CR>
xnoremap <silent> gx :call xdg_open#open(1)<CR>

### mundo.vim
nnoremap <Leader>u :MundoToggle<CR>
g:mundo_right = 1
g:mundo_help = 1
g:mundo_auto_preview = 0
g:mundo_verbose_graph = 0
augroup my-mundo
    au!
    au FileType Mundo,MundoDiff nnoremap <buffer> <C-w>c :normal q<CR>
augroup end

augroup alda
    au FileType alda setl makeprg=alda\ play\ --file\ %
augroup end

### Lpeg.vim
# g:lpeg_debug = 1
# augroup lpeg.vim-autostart
#     au Filetype * Lpeg autostart
# augroup end

def <SID>search_vix()
    var save = @a
    try
        normal! gv"sy
        @/ = '\V' .. substitute(escape(@s, '/\'), '\n', '\\n', 'g')
    finally
        @s = save
    endtry
enddef

#nnoremap g/ <C-o>:call <SID>search_vix()<CR>
nnoremap g/ <C-o>:call <SID>search_vix()<CR>/<C-R>=@/<CR><CR>

g:rust_recommended_style = 0

g:cc_align_no_map = 1

command! Slides {
    set showtabline=2 laststatus=0 cmdheight=1 number scrolloff=0
    &tabline = ' '
    hi LineNr      guifg=#ffffff
    hi EndOfBuffer guifg=#ffffff
    hi TabLineFill gui=NONE guibg=#ffffff term=NONE cterm=NONE

    # TODO: hide cursor better
    set virtualedit=all
    call cursor(1, winwidth(1))
    # Otherwise the cursor position won't update(?)
    normal! jk

    nnoremap j jzt
    nnoremap n nzt
    nnoremap N Nzt
    # TODO: these down't actually work?
    nnoremap <Down> jzt
    nnoremap <C-d>  jz<C-d>
    nnoremap <C-u>  jz<C-u>
    exe 'normal! zt'

    # TOOD: gives "no mapping found"?
    #nnoremap <Space> gt
    nnoremap <Right> gt
    nnoremap <Left>  gT
}

const registers = [
    '"',
    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
    '_',
    'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',
    'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',
    ':', '.', '%',
    '#',
    '=',
    '*', '+', '~',
    '/',
]

command -nargs=* Registers {
    var f = registers->copy()->filter((_, v) => getreg(v) =~ <q-args>)
    if len(f) == 0
        echo printf('no registers contain "%s"', <q-args>)
    else
        exe 'registers' f->join()
    endif
}

defcompile  # Compile functions so we get errors on startup.
# vim: et
